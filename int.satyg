@import: string
@import: char

module Int : sig
  val abs : int -> int
  val pow : int -> int -> int

  val bitsize : int
  val max-int : int
  val min-int : int

  % bitwise operations
  val lsl : int -> int -> int
  val asr : int -> int -> int
  val lsr : int -> int -> int
  val lnot : int -> int
  val land : int -> int -> int
  val lor : int -> int -> int
  val lxor : int -> int -> int

  val of-string : string -> int % may throw an error
end = struct
  let abs i = if i < 0 then -i else i
  let-rec pow p i =
    if p == 0 then
      1
    else
      i * pow (p - 1) i

  let bitsize = 63 % assume 64-bit machine
  let max-int = pow bitsize 2 - 1
  let min-int = max-int + 1

  let lnot i = (-i) - 1

  let-rec lsl shift i = i * pow shift 2
  let-rec asr shift i =
    if i >= 0 then
      i / pow shift 2
    else
      lnot (asr shift (lnot i))

  let bitwise-op op i j =
    let-rec aux n i j =
      if n == 0 then
        0
      else
        (aux (n - 1) (i |> asr 1) (j |> asr 1)) * 2 + op (abs (i mod 2)) (abs (j mod 2))
    in aux bitsize i j

  let land = bitwise-op (fun i j -> i * j)
  let lxor = bitwise-op (fun i j -> (i + j) mod 2)
  let lor = bitwise-op (fun i j -> 1 - (1 - i) * (1 - j))

  let lsr shift i =
    if i >= 0 then
      asr shift i
    else
      i |> asr shift |> land ((2 |> pow (bitsize - shift)) - 1)

  let of-string s =
    let cs = String.to-list s in
    match cs with
    | [] -> error `Int.of-string: invalid string`
    | c :: cs2 ->
      let (sign, cs) = if Char.equal c (Char.make `-`) then (-1, cs2) else (1, cs) in
      let num = cs |> List.fold-left (fun i c -> (match String.of-char c with
        | `0` -> i * 10
        | `1` -> i * 10 + 1
        | `2` -> i * 10 + 2
        | `3` -> i * 10 + 3
        | `4` -> i * 10 + 4
        | `5` -> i * 10 + 5
        | `6` -> i * 10 + 6
        | `7` -> i * 10 + 7
        | `8` -> i * 10 + 8
        | `9` -> i * 10 + 9
        | _   -> error `Int.of-string: invalid string`)) 0 in
      sign * num
end
