@import: list-ext
@import: option-ext
@import: string
@import: char
@import: fn
@import: result
@import: format
@import: ord
@import: int

type stream-position = (|
  line : int;  % one origin
  column : int;  % zero origin
|)

type token = Char.t * stream-position  % currently token's component is fixed to Char.t

module Stream : sig
  type t
  val of-string : string -> t
  val of-tokens : token list -> t
  val uncons : t -> (token * t) option
  val head : t -> token option
end = struct
  type t = token list

  let of-tokens ts = ts

  let of-string input =
    let-rec aux
    | [] _ acc = List.reverse acc
    | (c :: cs) pos acc =
      let token = (c, pos) in
      let new-pos =
        let line = pos#line + (if Char.equal c Char.newline then 1 else 0) in
        let column = if Char.equal c Char.newline then 0 else pos#column + 1 in
        (| line = line; column = column |)
      in aux cs new-pos ((c, new-pos) :: acc)
    in aux (String.to-list input) (| line = 1; column = 0 |) []

  let uncons s =
    match s with
    | [] -> Option.none
    | (t :: ts) -> Option.some (t, ts)
  
  let head =
    uncons |> Fn.compose (Option.map Tuple.fst)
end

type parse-error = (|
  token: token option;  % None for EOF
  desc: string
|)

module Parsec : sig
  type 'a t

  val run : 'a t -> Stream.t -> 'a (parse-error list) result

  % functor
  val map : ('a -> 'b) -> 'a t -> 'b t
  val (<&>) : 'a t -> ('a -> 'b) -> 'b t

  % applicative
  val pure : 'a -> 'a t
  val ap : 'a t -> ('a -> 'b) t -> 'b t
  val (<*>) : ('a -> 'b) t -> 'a t -> 'b t
  val (*>) : 'a t -> 'b t -> 'b t
  val (<*) : 'a t -> 'b t -> 'a t

  % monad
  val ret : 'a -> 'a t
  val bind : ('a -> 'b t) -> 'a t -> 'b t
  val (>>=) : 'a t -> ('a -> 'b t) -> 'b t
  val (>>) : 'a t -> 'b t -> 'b t
  val (<<) : 'a t -> 'b t -> 'a t

  % alternative
  val empty : 'a t
  val alt : 'a t -> 'a t -> 'a t   % predicative choice; the second parser is only tried when the first parser fails without consuming any tokens
  val (<|>) : 'a t -> 'a t -> 'a t
  val some : 'a t -> ('a list) t  % one or more; possessive by default, use `try` if necessary
  val many : 'a t -> ('a list) t  % zero or more; possessive by default, use `try` if necessary
  val optional : 'a t -> ('a option) t  % zero or one; possessive by default, use `try` if necessary
  val choice : ('a t) list -> 'a t  % possessive by default, use `try` if necessary

  % error handling
  val report : string -> unit t  % reports new error messege; always succeeds and never consumes input
  val label : string -> 'a t -> 'a t  % reports new error message on failure of the given parser regardless of consumption of input
  val (<?>) : 'a t -> string -> 'a t
  val fail : string -> 'a t

  % parsec
  val try : 'a t -> 'a t  % mark savepoints to perform backtracking
  val lookahead : 'a t -> 'a t
  val not-followed-by : 'a t -> unit t  % flip success and failure; never consumes input
  val catch : 'a t -> ('a option * parse-error list) t  % 
  val any : token t

  % derived combinators
  val eof : unit t
  val satisfy : (token -> bool) -> token t
  val char : Char.t -> Char.t t
  val string : string -> string t
  val some-sep-by : 'sep t -> 'a t -> ('a list) t
  val many-sep-by : 'sep t -> 'a t -> ('a list) t
  val between : 'open t -> 'close t -> 'a t -> 'a t
end = struct

  % state of parser
  type state = (|
    input : Stream.t;
  |)

  % indicates whether backtracking is to be performed on failure; see `alt`
  type consumption = Consumed | Virgin

  let (<+>) c1 c2 =
    match (c1, c2) with
    | (Virgin, Virgin) -> Virgin
    | _ -> Consumed

  % (Some a, _, []) -> parsing success with result a
  % (Some a, _, es) -> parsing continued while some errors were found and recovered (e.g. parsing continues after missing `}`)
  type 'a t = state -> (state * 'a) option * consumption * parse-error list

  let run p s =
    let initial-state = (| input = s |) in
    match p initial-state with
    | (Some (_, a), _, []) ->
      Result.ok a
    | (_, _, es) ->
      Result.err es

  let map f p s =
    match p s with
    | (Some (s, a), c, es) ->
      (Option.some (s, f a), c, es)
    | (None, c, es) ->
      (Option.none, c, es)

  let (<&>) p f = map f p

  let ret a s =
    (Option.some (s, a), Virgin, [])

  let bind k p s =
    match p s with
    | (Some (s, a), c1, e1) ->
      (match (k a) s with
      | (Some (s, b), c2, e2) ->
        (Option.some (s, b), c1 <+> c2, List.append e2 e1)
      | (None, c2, e2) ->
        (Option.none, c1 <+> c2, List.append e2 e1))
    | (None, c1, e1) ->
      (Option.none, c1, e1)

  let (>>=) p f = bind f p
  let (>>) p1 p2 = p1 >>= (fun _ -> p2)
  let (<<) p1 p2 = p1 >>= (fun x -> (p2 >> ret x))

  let pure = ret
  let ap p1 p2 = p2 >>= (fun f -> p1 >>= (fun x -> ret (f x)))
  let (<*>) p1 p2 = ap p2 p1
  let (*>) = (>>)
  let (<*) = (<<)

  let empty s =
    (Option.none, Virgin, [])

  let alt p1 p2 s =
    match p1 s with
    | (None, Virgin, e1) ->
      let (o, c, e2) = p2 s in
      (o, c, List.append e2 e1)
    | r -> r

  let (<|>) = alt

  let-rec
    many v = some v <|> pure []
  and
    some v = (pure List.cons <*> v) <*> many v

  let optional p = (pure Option.some <*> p) <|> pure Option.none

  let choice ps =
    List.fold-right alt empty ps

  % private API; impredictive choice a la PEG
  let (</>) p1 p2 s =
    match p1 s with
    | (None, c1, e1) ->
      let (o, c2, e2) = p2 s in
      (o, c2 <+> c1, List.append e2 e1)
    | r -> r

  let make-error s desc =
    (| token = Stream.head s#input; desc = desc |)

  let report desc s =
    (Option.some (s, ()), Virgin, [make-error s desc])

  let label desc p =
    p </> (report desc >> empty)

  let (<?>) p desc = label desc p

  let fail desc =
    empty <?> desc

  let try p s =
    match p s with
    | (None, _, e) ->
      (Option.none, Virgin, e)
    | r -> r

  let lookahead p s =
    match p s with
    | (Some (s, a), _, e) ->
      (Option.some (s, a), Virgin, e)
    | r -> r

  let not-followed-by p s =
    match p s with
    | (None, _, _) ->
      (Option.some (s, ()), Virgin, [])
    | _ ->
      (Option.none, Virgin, [])

  let catch p s =
    let (o, _, e) = p s in
    (Option.some (s, (o |> Option.map Tuple.snd, e)), Virgin, [])

  let any s =
    match Stream.uncons s#input with
    | None ->
      (Option.none, Virgin, [])
    | Some(t, new-input) ->
      (Option.some ((| input = new-input |), t), Consumed, [])

  % derived combinators

  let eof =
    not-followed-by any

  let satisfy pred =
    try (any >>= (fun t -> (
      if pred t then
        ret t
      else
        empty
    )))

  let char c =
    let test t = Char.equal (Tuple.fst t) c
    in satisfy test <&> Tuple.fst

  let string str =
    let-rec aux
    | [] = ret str
    | (c :: cs) = char c >> aux cs
    in try (aux (String.to-list str))

  let some-sep-by sep p =
    p >>= (fun x -> many (try (sep >> p)) >>= (fun xs -> ret (x :: xs)))

  let many-sep-by sep p = try (some-sep-by sep p) <|> ret []

  let between op cl p =
    op >> p >>= (fun x -> cl >> ret x)
end