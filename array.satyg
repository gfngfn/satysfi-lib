@require: list
@import: ref
@import: base

% # Polyfill for mutable array structure
% The current implementation is based on singly-linked lists and is very slow.
% The following code should be replaced with a more efficient implementation when
% the runtime support is ready.

module Array : sig
  type 'a t
  val length : 'a t -> int
  val get : int -> 'a t -> 'a
  val set : int -> 'a -> 'a t -> unit
  val make : int -> 'a -> 'a t
  val init : (int -> 'a) -> int -> 'a t
  val append : 'a t -> 'a t -> 'a t
  val concat : ('a t) list -> 'a t
%  val sub : 'a t -> int -> int -> 'a t
  val to-list : 'a t -> 'a list
  val of-list : 'a list -> 'a t
  val map : ('a -> 'b) -> 'a t -> 'b t
end = struct
  type 'a t = ('a ref) list
  let length = List.length
  let get i a = match a |> List.nth i with
  | None -> error `array: index out of range`
  | Some r -> Ref.get r
  let set i v a = match a |> List.nth i with
  | None -> error `array: index out of range`
  | Some r -> r |> Ref.set v
  let make n v =
    let-rec aux i acc =
      if i == n then
        acc
      else
        aux (i + 1) (Ref.make v :: acc)
    in aux 0 []
  let init f n =
    let-rec aux i =
      if i == n then
        []
      else
        let v = f i in
        Ref.make v :: aux (i + 1)
    in aux 0
  let append = List.append
  let concat = List.concat
  let to-list a = List.map Ref.get a
  let of-list l = List.map Ref.make l
  let map f a = of-list (List.map f (to-list a))

  % The following implementation is abandoned due to bad performance.
  % We will need more tuning and optimizations if we want to make this default.

  % type 'a u = ('a Ref.t) Map.t
  % type 'a t = 'a u

  % let-rec length a = Map.size a

  % let get i a =
  %   match a |> Map.get i with
  %   | None -> Error.error `array: index out of range`
  %   | Some(r) ->
  %     r |> Ref.get

  % let set i v a =
  %   match a |> Map.get i with
  %   | None -> Error.error `array: index out of range`
  %   | Some(r) ->
  %     r |> Ref.set v

  % let make n v =
  %   let-rec aux i acc =
  %     if i == n then
  %       acc
  %     else
  %       aux (i + 1) (acc |> Map.bind i (Ref.make v)) in
  %   aux 0 Map.empty

  % let init f n =
  %   let-rec aux i acc =
  %     if i == n then
  %       acc
  %     else
  %       aux (i + 1) ((i, Ref.make (f i)) :: acc) in
  %   let kvs = aux 0 [] in
  %   Map.of-list kvs

  % let-rec append a1 a2 =
  %   let l2 = Map.to-list a2 in
  %   let offset = length a1 in
  %   List.fold-left (fun a (k, v) -> (a |> Map.bind (k + offset) v)) a1 l2

  % let-rec concat xs = match xs with
  % | [] -> Map.empty
  % | x :: xs -> append x (concat xs)

  % let-rec to-list a =
  %   a |> Map.to-list
  %     |> List.map (compose Ref.get snd)

  % let-rec of-list l =
  %   Map.of-list (snd (List.fold-left (fun (n, acc) x -> (n + 1, (n, Ref.make x) :: acc)) (0, []) l))

  % let-rec map f a =
  %   a |> to-list
  %     |> List.map f
  %     |> of-list
end