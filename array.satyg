@require: list
@import: ref
@import: base

% # Polyfill for mutable array structure
% The current implementation is based on singly-linked lists and is very slow.
% The following code should be replaced with a more efficient implementation when
% the runtime support is ready.

module Array : sig
  type 'a t
  val length : 'a t -> int
  val get : int -> 'a t -> 'a
  val set : int -> 'a -> 'a t -> unit
  val make : int -> 'a -> 'a t
  val init : (int -> 'a) -> int -> 'a t
  val append : 'a t -> 'a t -> 'a t
  val concat : ('a t) list -> 'a t
%  val sub : 'a t -> int -> int -> 'a t
  val to-list : 'a t -> 'a list
  val of-list : 'a list -> 'a t
  val map : ('a -> 'b) -> 'a t -> 'b t
end = struct
  type 'a t = ('a ref) list
  let length = List.length
  let get i a = match a |> List.nth i with
  | None -> error `array: index out of range`
  | Some r -> Ref.get r
  let set i v a = match a |> List.nth i with
  | None -> error `array: index out of range`
  | Some r -> r |> Ref.set v
  let make n v =
    let-rec aux i acc =
      if i == n then
        acc
      else
        aux (i + 1) (Ref.make v :: acc)
    in aux 0 []
  let init f n =
    let-rec aux i =
      if i == n then
        []
      else
        let v = f i in
        Ref.make v :: aux (i + 1)
    in aux 0
  let append = List.append
  let concat = List.concat
  let to-list a = List.map Ref.get a
  let of-list l = List.map Ref.make l
  let map f a = of-list (List.map f (to-list a))
end