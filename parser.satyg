% PEG-like monadic parser combinator

@require: list
@require: option
@import: option2
@import: string
@import: char
@import: fn

type 's 'a parser = 's -> ('a * 's) option

module Parser : sig
  % type 's 'a parser
  val return : 'a -> 's 'a parser
  val bind : 's 'a parser -> ('a -> 's 'b parser) -> 's 'b parser
  val (>>=) : 's 'a parser -> ('a -> 's 'b parser) -> 's 'b parser
  val (>>) : 's 'a parser -> 's 'b parser -> 's 'b parser
  val fail : 's 'a parser
  val alt : 's 'a parser -> 's 'a parser -> 's 'a parser
  val (<|>) : 's 'a parser -> 's 'a parser -> 's 'a parser
  val many1 : 's 'a parser -> 's ('a list) parser
  val many : 's 'a parser -> 's ('a list) parser
  val sepby1 : 's 'a parser -> 's 'b parser -> 's ('b list) parser
  val sepby : 's 'a parser -> 's 'b parser -> 's ('b list) parser
  val lookahead : ('s -> bool) -> 's unit parser
  val between : 's 'a parser -> 's 'b parser -> 's 'c parser -> 's 'c parser
  val run : 's -> 's 'a parser -> ('a * 's) option

  val satisfy : (Char.t -> bool) -> string Char.t parser
  val any-char : string Char.t parser
  val char : Char.t -> string Char.t parser
  val string : string -> string string parser
end = struct
  let return x s = Some (x, s)
  let bind p f s = p s |> Option.map (fun (x,s) -> f x s) |> Option2.join
  let (>>=) = bind
  let (>>) = fun p q -> p >>= (fun _ -> q)
  let fail s = None
  let alt p q s = match p s with
  | None -> q s
  | Some x -> Some x
  let (<|>) = alt

  let-rec many1 p =
    p >>= (fun x -> (many1 p <|> return []) >>= (fun xs -> return (x :: xs)))
  let many p = many1 p <|> return []

  let-rec sepby1 sep p =
    p >>= (fun x -> (many (sep >> p) <|> return []) >>= (fun xs -> return (x :: xs)))
  let sepby sep p = sepby1 sep p <|> return []
    
  let lookahead f s = if f s then Some ((), s) else None

  let between op cl p =
    op >> p >>= (fun x -> cl >> return x)

  let run s p = p s

  let satisfy f s =
    let len = String.length s in
    if ~(&(len > 0) &&& &(f (Char.at 0 s))) then
      Some (s |> Char.at 0, s |> String.sub 1 (len - 1))
    else      
      None
  let any-char = satisfy (Fn.const true)
  let char c = satisfy (Char.equal c)
  let string str s =
    if s |> String.starts-with str then
      Some(s |> String.split (String.length str))
    else
      None
end