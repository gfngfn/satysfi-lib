@import: base
@require: option
@import: fn

module Option2 : sig
  val is-none : 'a option -> bool
  val is-some : 'a option -> bool
  val join : ('a option) option -> 'a option
  val value : 'a -> 'a option -> 'a
  val (^&&) : bool option -> bool option -> bool option
  val (^||) : bool option -> bool option -> bool option
  val (^::) : 'a option -> ('a list) option -> ('a list) option
  val (^+) : int option -> int option -> int option
  val (^-) : int option -> int option -> int option
  val (^*) : int option -> int option -> int option
  val (^/) : int option -> int option -> int option
  val (^+.) : float option -> float option -> float option
  val (^-.) : float option -> float option -> float option
  val (^*.) : float option -> float option -> float option
  val (^/.) : float option -> float option -> float option
  val (^+') : length option -> length option -> length option
  val (^-') : length option -> length option -> length option
  val (^*') : length option -> float option -> length option
  val (^/') : length option -> length option -> float option
end = struct
  let-rec is-none
    | (None) = true
    | (Some(_)) = false

  let-rec is-some
    | (None) = false
    | (Some(_)) = true
  
  let join m = Option.bind m Fn.id
  let (^&&) b-opt1 b-opt2 =
    match (b-opt1, b-opt2) with
    | (Some(b1), Some(b2)) -> Some(b1 && b2)
    | (_, _)               -> None

  let value default-val opt = match opt with
  | None -> default-val
  | Some v -> v

  let (^||) b-opt1 b-opt2 =
    match (b-opt1, b-opt2) with
    | (Some(b1), Some(b2)) -> Some(b1 || b2)
    | (_, _)               -> None

  let (^::) a-opt1 lst-opt2 =
    match (a-opt1, lst-opt2) with
    | (Some(x), Some(xs)) -> Some(x :: xs)
    | (_, _)              -> None

  let (^+) i-opt1 i-opt2 =
    match (i-opt1, i-opt2) with
    | (Some(i1), Some(i2)) -> Some(i1 + i2)
    | (_, _)               -> None

  let (^-) i-opt1 i-opt2 =
    match (i-opt1, i-opt2) with
    | (Some(i1), Some(i2)) -> Some(i1 - i2)
    | (_, _)               -> None

  let (^*) i-opt1 i-opt2 =
    match (i-opt1, i-opt2) with
    | (Some(i1), Some(i2)) -> Some(i1 * i2)
    | (_, _)               -> None

  let (^/) i-opt1 i-opt2 =
    match (i-opt1, i-opt2) with
    | (Some(i1), Some(i2)) -> Some(i1 / i2)
    | (_, _)               -> None

  let (^+.) f-opt1 f-opt2 =
    match (f-opt1, f-opt2) with
    | (Some(f1), Some(f2)) -> Some(f1 +. f2)
    | (_, _)               -> None

  let (^-.) f-opt1 f-opt2 =
    match (f-opt1, f-opt2) with
    | (Some(f1), Some(f2)) -> Some(f1 -. f2)
    | (_, _)               -> None

  let (^*.) f-opt1 f-opt2 =
    match (f-opt1, f-opt2) with
    | (Some(f1), Some(f2)) -> Some(f1 *. f2)
    | (_, _)               -> None

  let (^/.) f-opt1 f-opt2 =
    match (f-opt1, f-opt2) with
    | (Some(f1), Some(f2)) -> Some(f1 /. f2)
    | (_, _)               -> None

  let (^+') l-opt1 l-opt2 =
    match (l-opt1, l-opt2) with
    | (Some(l1), Some(l2)) -> Some(l1 +' l2)
    | (_, _)               -> None

  let (^-') l-opt1 l-opt2 =
    match (l-opt1, l-opt2) with
    | (Some(l1), Some(l2)) -> Some(l1 -' l2)
    | (_, _)               -> None

  let (^*') l-opt1 f-opt2 =
    match (l-opt1, f-opt2) with
    | (Some(l1), Some(f2)) -> Some(l1 *' f2)
    | (_, _)               -> None

  let (^/') l-opt1 l-opt2 =
    match (l-opt1, l-opt2) with
    | (Some(l1), Some(l2)) -> Some(l1 /' l2)
    | (_, _)               -> None
end
