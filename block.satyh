% module for block-boxes

@require: list
@import: fn
@require: deco
@import: length
@import: inline

module Block : sig
  val read : block-text -> context -> block-boxes
  val of-inline : bool ?-> bool -> bool -> (context -> inline-boxes) -> context -> block-boxes

  val skip : length -> block-boxes

  val nil : block-boxes
  val append : block-boxes -> block-boxes -> block-boxes
  val concat : block-boxes list -> block-boxes

  val natural-length : block-boxes -> length

  val centering : (context -> inline-boxes) -> context -> block-boxes

  val frame-breakable : (length * length * length * length) -> deco-set -> (context -> block-boxes) -> context -> block-boxes
end = struct
  let read = Fn.flip read-block
  let of-inline ?:fill-tail b1 b2 ibf ctx =
    let tail = match fill-tail with
    | Some(true) -> Inline.fil
    | _ -> Inline.nil
  in line-break b1 b2 ctx ((ibf ctx) ++ tail)

  let skip = block-skip

  let nil = block-nil
  let append b1 b2 = b1 +++ b2
  let concat bbs = List.fold-right append nil bbs

  let natural-length = get-natural-length

  % Centerize only if the length is less than the length of the page
  let centering ibf ctx =
    let text-width = ctx |> get-text-width in
    let ib = ctx |> ibf in
    let ib-center =
      if Length.(get-natural-width ib > text-width) then
        ib ++ Inline.fil
      else
        Inline.fil ++ ib ++ Inline.fil
    in ctx |> of-inline true true (Fn.const ib-center)

  let frame-breakable pads deco f ctx = block-frame-breakable ctx pads deco f
end